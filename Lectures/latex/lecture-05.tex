\section{Lecture 5: Number Representation and Instruction Encoding}

\emph{By Dr. Kisaru Liyanage}

\subsection{Introduction}

This lecture delves into how computers represent and manipulate data at the binary level. We explore number systems, two's complement representation for signed integers, instruction encoding formats in ARM assembly, and logical operations for bit manipulation. Understanding these fundamentals is essential for programming efficiently in assembly language and comprehending how processors execute arithmetic and logical operations.

\subsection{Number Representation Systems}

\subsubsection{Unsigned Binary Integers}

\textbf{Binary System Basics}

\begin{itemize}
\item Base-2 number system using digits 0 and 1
\item Each bit position represents a power of 2
\item Rightmost bit is least significant (LSB)
\item Leftmost bit is most significant (MSB)

\textbf{Place Value Calculation}

\begin{verbatim}
Binary: 1011
Value = (1 × 2³) + (0 × 2²) + (1 × 2¹) + (1 × 2⁰)
      = 8 + 0 + 2 + 1
      = 11 (decimal)
\end{verbatim}

\textbf{N-Bit Unsigned Range}

\begin{itemize}
\item N bits can represent 2^N different values
\item Range: 0 to (2^N - 1)
\item 8 bits: 0 to 255
\item 32 bits: 0 to 4,294,967,295

\textbf{Binary to Decimal Conversion}

\begin{verbatim}
Example: 10110101
= 1×128 + 0×64 + 1×32 + 1×16 + 0×8 + 1×4 + 0×2 + 1×1
= 128 + 32 + 16 + 4 + 1
= 181
\end{verbatim}

\subsubsection{Two's Complement Representation}

\textbf{Purpose of Two's Complement}

\begin{itemize}
\item Represents both positive and negative integers
\item Simplifies hardware (same adder for signed/unsigned)
\item Unique zero representation
\item Natural overflow behavior

\textbf{Sign Bit}

\begin{itemize}
\item MSB indicates sign
\item MSB = 0: Positive number
\item MSB = 1: Negative number

\textbf{Positive Numbers}

\begin{itemize}
\item Same as unsigned binary
\item MSB is always 0
\item Example: +5 in 8 bits = 00000101

\textbf{Negative Numbers}

\begin{itemize}
\item Represented as 2^N - |value|
\item Example: -5 in 8 bits:
\begin{verbatim}
  2^8 - 5 = 256 - 5 = 251 = 11111011
\end{verbatim}

\textbf{Two's Complement Conversion}
Method 1 (Invert and Add):

\begin{enumerate}
\item Write positive value in binary
\item Invert all bits (0$\rightarrow$1, 1$\rightarrow$0)
\item Add 1 to result

Example: -5 in 8 bits

\begin{verbatim}
+5:        00000101
Invert:    11111010
Add 1:     11111011  (this is -5)
\end{verbatim}

Method 2 (Subtraction):

\begin{verbatim}
-5 = 2^8 - 5 = 256 - 5 = 251 = 11111011
\end{verbatim}

\textbf{N-Bit Signed Range}

\begin{itemize}
\item Range: -(2^(N-1)) to +(2^(N-1) - 1)
\item 8 bits: -128 to +127
\item 32 bits: -2,147,483,648 to +2,147,483,647

\textbf{Special Cases}

\begin{itemize}
\item Zero: 00000000 (unique representation)
\item Most negative: 10000000 (-128 in 8 bits)
\item Has no positive counterpart!
\item Negating gives overflow

\subsubsection{Sign Extension}

\textbf{Purpose}

\begin{itemize}
\item Extend smaller signed value to larger width
\item Preserve numerical value
\item Required when loading bytes/halfwords into 32-bit registers

\textbf{Process}

\begin{itemize}
\item Replicate the sign bit (MSB) to fill new bits
\item Preserves positive/negative value

\textbf{Examples}

\begin{verbatim}
8-bit to 32-bit:
00000101 (+5) $\rightarrow$ 00000000 00000000 00000000 00000101 (+5)
11111011 (-5) $\rightarrow$ 11111111 11111111 11111111 11111011 (-5)
\end{verbatim}

\textbf{ARM Instructions for Sign Extension}

\begin{itemize}
\item \textbf{LDRH}: Load halfword (16 bits), zero-extend to 32 bits
\item \textbf{LDRSH}: Load signed halfword, sign-extend to 32 bits
\item \textbf{LDRB}: Load byte (8 bits), zero-extend to 32 bits
\item \textbf{LDRSB}: Load signed byte, sign-extend to 32 bits

\textbf{Example Usage}

\begin{lstlisting}[language=assembly]
LDRH R0, [R1]     ; R0 = 0x0000ABCD (zero-extended)
LDRSH R0, [R1]    ; R0 = 0xFFFFABCD (sign-extended if bit 15 = 1)

LDRB R0, [R1]     ; R0 = 0x000000AB (zero-extended)
LDRSB R0, [R1]    ; R0 = 0xFFFFFFAB (sign-extended if bit 7 = 1)
\end{verbatim}

\subsubsection{Hexadecimal Notation}

\textbf{Why Hexadecimal?}

\begin{itemize}
\item Compact representation of binary
\item One hex digit = 4 binary bits
\item Easier to read than long binary strings
\item Common in programming and debugging

\textbf{Hex Digits}

\begin{verbatim}
Binary  | Hex | Decimal
--------|-----|--------
0000    |  0  |   0
0001    |  1  |   1
0010    |  2  |   2
0011    |  3  |   3
0100    |  4  |   4
0101    |  5  |   5
0110    |  6  |   6
0111    |  7  |   7
1000    |  8  |   8
1001    |  9  |   9
1010    |  A  |  10
1011    |  B  |  11
1100    |  C  |  12
1101    |  D  |  13
1110    |  E  |  14
1111    |  F  |  15
\end{verbatim}

\textbf{Conversion Examples}

\begin{verbatim}
Binary: 1011 0110 1101 0010
Hex:      B    6    D    2
Result: 0xB6D2

Hex: 0x3F
Binary: 0011 1111
Decimal: 63
\end{verbatim}

\textbf{ARM Hexadecimal Usage}

\begin{lstlisting}[language=assembly]
MOV R0, #0xFF        ; R0 = 255
MOV R1, #0x100       ; R1 = 256
LDR R2, =0xDEADBEEF  ; R2 = 3735928559
\end{verbatim}

\subsection{ARM Instruction Encoding}

\subsubsection{Fixed-Length Instructions}

\textbf{32-Bit Instruction Format}

\begin{itemize}
\item Every ARM instruction is exactly 32 bits
\item Simplifies instruction fetch and decode
\item Enables efficient pipelining

\textbf{Advantages}

\begin{itemize}
\item Predictable instruction boundaries
\item Simple PC increment (always +4)
\item Fast decode logic

\textbf{Trade-offs}

\begin{itemize}
\item Some instructions may "waste" bits
\item Immediate values limited in size
\item Code density lower than variable-length (e.g., x86)

\subsubsection{Data Processing Instruction Format}

\textbf{Format Structure}

\begin{verbatim}
[Cond][00][I][Opcode][S][Rn][Rd][Operand2]
 4-bit 2  1   4-bit   1  4   4   12-bit
\end{verbatim}

\textbf{Field Descriptions}

\textbf{Condition (4 bits, bits 28-31)}

\begin{itemize}
\item Conditional execution feature
\item 0000 = EQ (equal, Z=1)
\item 0001 = NE (not equal, Z=0)
\item 1010 = GE (greater or equal, signed)
\item 1110 = AL (always execute, default)

\textbf{I bit (bit 25)}

\begin{itemize}
\item 0 = Operand2 is register
\item 1 = Operand2 is immediate value

\textbf{Opcode (4 bits, bits 21-24)}

\begin{itemize}
\item Specifies operation (AND, EOR, SUB, ADD, etc.)
\item 0100 = ADD
\item 0010 = SUB
\item 0000 = AND
\item 1100 = ORR

\textbf{S bit (bit 20)}

\begin{itemize}
\item 0 = Don't update condition flags
\item 1 = Update flags (CPSR)

\textbf{Rn (4 bits, bits 16-19)}

\begin{itemize}
\item First operand register number
\item 0000 = R0, 0001 = R1, etc.

\textbf{Rd (4 bits, bits 12-15)}

\begin{itemize}
\item Destination register number

\textbf{Operand2 (12 bits, bits 0-11)}

\begin{itemize}
\item If I=0: Shift amount and second register
\item If I=1: 8-bit immediate + 4-bit rotation

\textbf{Example: ADD R0, R1, R2}

\begin{verbatim}
Encoding fields:
- Cond: 1110 (always)
- I: 0 (register operand)
- Opcode: 0100 (ADD)
- S: 0 (don't update flags)
- Rn: 0001 (R1)
- Rd: 0000 (R0)
- Operand2: 0002 (R2, no shift)

Result: 0xE0810002
\end{verbatim}

\subsubsection{Data Transfer Instruction Format}

\textbf{Format Structure}

\begin{verbatim}
[Cond][01][I][P][U][B][W][L][Rn][Rd][Offset]
 4-bit 2  1  1  1  1  1  1  4   4   12-bit
\end{verbatim}

\textbf{Key Fields}

\textbf{L bit (bit 20)}

\begin{itemize}
\item 0 = Store (STR)
\item 1 = Load (LDR)

\textbf{B bit (bit 22)}

\begin{itemize}
\item 0 = Word transfer (32 bits)
\item 1 = Byte transfer (8 bits)

\textbf{P bit (bit 24)}

\begin{itemize}
\item 0 = Post-indexed addressing
\item 1 = Pre-indexed or offset addressing

\textbf{U bit (bit 23)}

\begin{itemize}
\item 0 = Subtract offset from base
\item 1 = Add offset to base

\textbf{W bit (bit 21)}

\begin{itemize}
\item 0 = No write-back
\item 1 = Write-back (update base register)

\textbf{Rn (base register)}

\begin{itemize}
\item Contains memory address or base address

\textbf{Rd (data register)}

\begin{itemize}
\item For Load: Destination register
\item For Store: Source register

\textbf{Offset (12 bits)}

\begin{itemize}
\item Memory address offset
\item Can be immediate or register

\textbf{Example: LDR R0, [R1, \#4]}

\begin{verbatim}
Encoding fields:
- Cond: 1110 (always)
- L: 1 (load)
- B: 0 (word)
- P: 1 (offset addressing)
- U: 1 (add offset)
- Rn: 0001 (R1)
- Rd: 0000 (R0)
- Offset: 004 (immediate 4)

Result: 0xE5910004
\end{verbatim}

\subsubsection{Immediate Value Encoding}

\textbf{Challenge}

\begin{itemize}
\item 32-bit instruction must fit: opcode, registers, immediate
\item Cannot fit full 32-bit immediate

\textbf{ARM Solution: 8-bit + 4-bit Rotation}

\begin{itemize}
\item Immediate field: 12 bits total
\item Lower 8 bits: Immediate value (0-255)
\item Upper 4 bits: Rotation amount (0-15)
\item Rotation: Right by (2 $\times$ rotation field) bits

\textbf{Calculation}

\begin{verbatim}
Actual Value = Immediate × ROR (2 × Rotation)
\end{verbatim}

\textbf{Examples}

\begin{verbatim}
Immediate=0xFF, Rotation=0:
  Value = 0xFF ROR 0 = 0x000000FF

Immediate=0xFF, Rotation=8:
  Value = 0xFF ROR 16 = 0x00FF0000

Immediate=0xFF, Rotation=12:
  Value = 0xFF ROR 24 = 0xFF000000
\end{verbatim}

\textbf{Allowed Immediates}

\begin{itemize}
\item Not all 32-bit values can be encoded
\item Valid: 0xFF, 0xFF00, 0xFF0000, 0xFF000000
\item Valid: 0xFF000000FF (rotation wraps around)
\item Invalid: 0x123 (cannot be formed by rotation)

\textbf{Assembler Handling}

\begin{itemize}
\item Assembler checks if immediate is valid
\item Gives error if immediate cannot be encoded
\item Use LDR pseudo-instruction for arbitrary values:
\begin{lstlisting}[language=assembly]
  LDR R0, =0x12345678  ; Loads from literal pool
\end{verbatim}

\subsection{Logical Operations}

\subsubsection{Bitwise AND}

\textbf{Operation}

\begin{itemize}
\item Performs logical AND on each bit pair
\item Result bit = 1 only if both input bits are 1

\textbf{Truth Table}

\begin{verbatim}
A | B | A AND B
--|---|--------
0 | 0 |   0
0 | 1 |   0
1 | 0 |   0
1 | 1 |   1
\end{verbatim}

\textbf{ARM Instruction}

\begin{lstlisting}[language=assembly]
AND Rd, Rn, Rm       ; Rd = Rn AND Rm
AND Rd, Rn, #imm     ; Rd = Rn AND immediate
\end{verbatim}

\textbf{Common Uses}

\textbf{Bit Masking (Extract Specific Bits)}

\begin{lstlisting}[language=assembly]
; Extract lower 8 bits of R1
MOV R0, R1
AND R0, R0, #0xFF    ; R0 = R1 & 0xFF (keep bits 0-7)

; Extract bits 8-15
MOV R0, R1
AND R0, R0, #0xFF00  ; R0 = R1 & 0xFF00 (keep bits 8-15)
\end{verbatim}

\textbf{Clearing Specific Bits}

\begin{lstlisting}[language=assembly]
; Clear bit 5 of R1
AND R1, R1, #0xFFFFFFDF  ; Bit 5 mask: ~(1 << 5)
\end{verbatim}

\textbf{Checking if Bit Set}

\begin{lstlisting}[language=assembly]
AND R2, R1, #0x80    ; Check if bit 7 is set
CMP R2, #0           ; Compare with zero
BEQ bit_clear        ; Branch if bit was clear
\end{verbatim}

\subsubsection{Bitwise OR}

\textbf{Operation}

\begin{itemize}
\item Performs logical OR on each bit pair
\item Result bit = 1 if either input bit is 1

\textbf{Truth Table}

\begin{verbatim}
A | B | A OR B
--|---|-------
0 | 0 |   0
0 | 1 |   1
1 | 0 |   1
1 | 1 |   1
\end{verbatim}

\textbf{ARM Instruction}

\begin{lstlisting}[language=assembly]
ORR Rd, Rn, Rm       ; Rd = Rn OR Rm (ORR in ARM)
ORR Rd, Rn, #imm     ; Rd = Rn OR immediate
\end{verbatim}

\textbf{Common Uses}

\textbf{Setting Specific Bits}

\begin{lstlisting}[language=assembly]
; Set bit 3 of R1
ORR R1, R1, #0x08    ; Bit 3 mask: (1 << 3) = 0x08

; Set bits 4 and 5
ORR R1, R1, #0x30    ; Mask: 0x30 = 0b00110000
\end{verbatim}

\textbf{Combining Values}

\begin{lstlisting}[language=assembly]
; Combine lower byte of R1 with upper bytes of R2
AND R1, R1, #0xFF        ; Keep only lower byte
AND R2, R2, #0xFFFFFF00  ; Keep only upper bytes
ORR R0, R1, R2           ; Combine
\end{verbatim}

\subsubsection{Bitwise XOR (Exclusive OR)}

\textbf{Operation}

\begin{itemize}
\item Performs logical XOR on each bit pair
\item Result bit = 1 if input bits differ

\textbf{Truth Table}

\begin{verbatim}
A | B | A XOR B
--|---|--------
0 | 0 |   0
0 | 1 |   1
1 | 0 |   1
1 | 1 |   0
\end{verbatim}

\textbf{ARM Instruction}

\begin{lstlisting}[language=assembly]
EOR Rd, Rn, Rm       ; Rd = Rn EOR Rm (EOR in ARM)
EOR Rd, Rn, #imm     ; Rd = Rn EOR immediate
\end{verbatim}

\textbf{Common Uses}

\textbf{Toggling Specific Bits}

\begin{lstlisting}[language=assembly]
; Toggle bit 2 of R1
EOR R1, R1, #0x04    ; Bit 2 mask: (1 << 2)
; If bit was 0, becomes 1; if was 1, becomes 0
\end{verbatim}

\textbf{Fast Zero}

\begin{lstlisting}[language=assembly]
EOR R0, R0, R0       ; R0 = 0 (XOR with itself)
\end{verbatim}

\textbf{Comparison}

\begin{lstlisting}[language=assembly]
; Check if R1 and R2 are equal
EOR R3, R1, R2       ; R3 = R1 XOR R2
CMP R3, #0           ; If R3 = 0, R1 == R2
BEQ values_equal
\end{verbatim}

\textbf{Swapping Without Temporary}

\begin{lstlisting}[language=assembly]
; Swap R0 and R1 without using another register
EOR R0, R0, R1
EOR R1, R0, R1
EOR R0, R0, R1
; Now R0 and R1 are swapped
\end{verbatim}

\subsubsection{Bitwise NOT}

\textbf{Operation}

\begin{itemize}
\item Inverts all bits (0$\rightarrow$1, 1$\rightarrow$0)
\item Also called complement

\textbf{ARM Instruction}

\begin{lstlisting}[language=assembly]
MVN Rd, Rm           ; Rd = NOT Rm (Move Not)
MVN Rd, #imm         ; Rd = NOT immediate
\end{verbatim}

\textbf{Common Uses}

\textbf{Creating Bit Masks}

\begin{lstlisting}[language=assembly]
; Create mask with all bits set except bit 3
MOV R0, #0x08        ; 0x08 = 0b00001000
MVN R1, R0           ; R1 = 0xFFFFFFF7 (all except bit 3)
\end{verbatim}

\textbf{Negation (with ADD)}

\begin{lstlisting}[language=assembly]
; Negate R1 (two's complement)
MVN R1, R1           ; Invert all bits
ADD R1, R1, #1       ; Add 1
; Now R1 = -R1 (original)
\end{verbatim}

\subsubsection{Shift Operations}

\textbf{Logical Shift Left (LSL)}

\begin{lstlisting}[language=assembly]
LSL Rd, Rn, #shift   ; Rd = Rn << shift
MOV Rd, Rn, LSL #shift
\end{verbatim}

\begin{itemize}
\item Shifts bits left, fills right with zeros
\item Each shift left multiplies by 2
\item Example: 0b00001010 LSL 2 = 0b00101000

\textbf{Logical Shift Right (LSR)}

\begin{lstlisting}[language=assembly]
LSR Rd, Rn, #shift   ; Rd = Rn >> shift (unsigned)
MOV Rd, Rn, LSR #shift
\end{verbatim}

\begin{itemize}
\item Shifts bits right, fills left with zeros
\item Each shift right divides by 2 (unsigned)
\item Example: 0b10100000 LSR 2 = 0b00101000

\textbf{Arithmetic Shift Right (ASR)}

\begin{lstlisting}[language=assembly]
ASR Rd, Rn, #shift   ; Rd = Rn >> shift (signed)
\end{verbatim}

\begin{itemize}
\item Shifts bits right, fills left with sign bit
\item Preserves sign for signed division
\item Example: 0b11110000 ASR 2 = 0b11111100 (sign preserved)

\textbf{Rotate Right (ROR)}

\begin{lstlisting}[language=assembly]
ROR Rd, Rn, #shift   ; Rotate Rn right by shift
\end{verbatim}

\begin{itemize}
\item Bits shifted out right reappear at left
\item No information lost
\item Example: 0b10000001 ROR 1 = 0b11000000

\textbf{Common Shift Applications}

\textbf{Fast Multiplication/Division by Powers of 2}

\begin{lstlisting}[language=assembly]
LSL R0, R1, #3       ; R0 = R1 × 8 (2^3)
LSR R0, R1, #2       ; R0 = R1 / 4 (unsigned)
ASR R0, R1, #2       ; R0 = R1 / 4 (signed)
\end{verbatim}

\textbf{Bit Extraction}

\begin{lstlisting}[language=assembly]
; Extract bits 8-11 from R1
LSR R0, R1, #8       ; Shift bits 8-11 to bits 0-3
AND R0, R0, #0xF     ; Mask to keep only 4 bits
\end{verbatim}

\textbf{Bit Positioning}

\begin{lstlisting}[language=assembly]
; Move bit 0 to bit 7
LSL R0, R1, #7       ; Shift left 7 positions
AND R0, R0, #0x80    ; Keep only bit 7
\end{verbatim}

\subsection{Practical Bit Manipulation Examples}

\subsubsection{Extracting Bit Fields}

\textbf{Extract bits 16-23}

\begin{lstlisting}[language=assembly]
LSR R0, R1, #16      ; Shift right to position
AND R0, R0, #0xFF    ; Mask to 8 bits
\end{verbatim}

\textbf{Extract bits 4-9 (6 bits)}

\begin{lstlisting}[language=assembly]
LSR R0, R1, #4       ; Shift to position 0
AND R0, R0, #0x3F    ; Mask to 6 bits (0b111111)
\end{verbatim}

\subsubsection{Setting and Clearing Bits}

\textbf{Set bits 8-15}

\begin{lstlisting}[language=assembly]
ORR R1, R1, #0xFF00  ; Set bits 8-15
\end{verbatim}

\textbf{Clear bits 16-23}

\begin{lstlisting}[language=assembly]
LDR R0, =0xFF00FFFF  ; Mask with bits 16-23 clear
AND R1, R1, R0       ; Clear bits 16-23 of R1
\end{verbatim}

\textbf{Toggle bits 0-7}

\begin{lstlisting}[language=assembly]
EOR R1, R1, #0xFF    ; Toggle lower byte
\end{verbatim}

\subsubsection{Checking Flags}

\textbf{Check if any of bits 4-7 are set}

\begin{lstlisting}[language=assembly]
AND R2, R1, #0xF0    ; Mask bits 4-7
CMP R2, #0           ; Check if zero
BNE bits_set         ; Branch if any bit was set
\end{verbatim}

\textbf{Check if specific pattern matches}

\begin{lstlisting}[language=assembly]
; Check if bits 8-11 are 0b1010
LSR R0, R1, #8       ; Position bits
AND R0, R0, #0xF     ; Mask 4 bits
CMP R0, #0xA         ; Compare with 0b1010
BEQ pattern_match
\end{verbatim}

\subsubsection{Color Packing/Unpacking}

\textbf{Pack RGB values (8 bits each)}

\begin{lstlisting}[language=assembly]
; R0 = Red, R1 = Green, R2 = Blue
LSL R1, R1, #8       ; Green << 8
LSL R2, R2, #16      ; Blue << 16
ORR R3, R0, R1       ; Combine Red and Green
ORR R3, R3, R2       ; Combine with Blue
; R3 now contains 0x00BBGGRR
\end{verbatim}

\textbf{Unpack RGB values}

\begin{lstlisting}[language=assembly]
; R0 contains 0x00BBGGRR
AND R1, R0, #0xFF      ; Extract Red
LSR R2, R0, #8
AND R2, R2, #0xFF      ; Extract Green
LSR R3, R0, #16
AND R3, R3, #0xFF      ; Extract Blue
\end{verbatim}

\subsection{Key Takeaways}

\begin{enumerate}
\item \textbf{Unsigned binary integers} represent values from 0 to 2^N - 1 using N bits.

\begin{enumerate}
\item \textbf{Two's complement} represents signed integers, with MSB as sign bit and range -(2^(N-1)) to +(2^(N-1) - 1).

\begin{enumerate}
\item \textbf{Sign extension} preserves value when expanding narrower signed values to wider registers.

\begin{enumerate}
\item \textbf{Hexadecimal notation} provides compact representation with one hex digit per 4 binary bits.

\begin{enumerate}
\item \textbf{ARM instructions are fixed 32-bit length}, simplifying fetch/decode but limiting immediate values.

\begin{enumerate}
\item \textbf{Data processing format} includes condition, opcode, source/destination registers, and operand.

\begin{enumerate}
\item \textbf{Data transfer format} specifies load/store, byte/word, addressing mode, and offset.

\begin{enumerate}
\item \textbf{Immediate encoding} uses 8-bit value + 4-bit rotation, limiting which constants can be encoded directly.

\begin{enumerate}
\item \textbf{Bitwise AND} used for masking (extracting specific bits) and clearing bits.

10. \textbf{Bitwise OR} used for setting specific bits and combining values.

11. \textbf{Bitwise XOR} used for toggling bits, fast zero, and comparisons.

12. \textbf{Shift operations} enable fast multiplication/division by powers of 2 and bit positioning.

13. \textbf{Bit manipulation} is fundamental for low-level programming, hardware control, and optimization.

14. \textbf{Understanding encoding} helps write efficient assembly and debug machine code issues.

\subsection{Summary}

Number representation and instruction encoding form the foundation of low-level programming. Two's complement enables efficient signed arithmetic with simple hardware, while sign extension preserves values across different data sizes. ARM's fixed 32-bit instruction format provides regularity but imposes constraints on immediate values, solved through clever encoding schemes. Logical operations—AND, OR, XOR, and NOT—combined with shift operations, provide powerful tools for bit manipulation essential in systems programming, embedded development, and performance optimization. Mastering these concepts enables efficient assembly programming and deeper understanding of how high-level operations translate to machine instructions. These fundamentals prepare us for more complex topics including branching, function calls, and memory management.
