\section{Lecture 20: Storage and Input/Output Systems}

\emph{By Dr. Swarnalatha Radhakrishnan}

\subsection{Introduction}

This lecture completes our exploration of computer architecture by examining storage devices and input/output (I/O) systems that enable computers to interact with external devices and provide persistent data storage beyond volatile main memory. We explore storage technologies from mechanical magnetic disks to solid-state flash memory, understanding their performance characteristics, reliability metrics, and cost tradeoffs. The lecture covers I/O communication methods including polling, interrupts, and direct memory access (DMA), analyzes RAID configurations that improve both performance and dependability, and examines how storage systems connect to processors through memory-mapped I/O or dedicated I/O instructions. Understanding these peripheral systems reveals how complete computer systems integrate computation, memory, and external interaction into cohesive platforms.

\subsection{I/O Device Characteristics}

I/O devices can be characterized by three fundamental factors:

\subsubsection{Behavior}

\textbf{Input Devices}:

\begin{itemize}
\item Provide data to system
\item Examples: keyboards, mice, sensors

\textbf{Output Devices}:

\begin{itemize}
\item Receive data from system
\item Examples: displays, printers, speakers

\textbf{Storage Devices}:

\begin{itemize}
\item Store and retrieve data
\item Examples: disks, flash drives

\subsubsection{Partner}

\textbf{Human Devices}:

\begin{itemize}
\item Communicate with humans
\item Examples: keyboards, displays, audio

\textbf{Machine Devices}:

\begin{itemize}
\item Communicate with other machines
\item Examples: networks, controllers

\subsubsection{Data Rate}

\begin{itemize}
\item Measured in bytes per second or transfers per second
\item Wide variation across device types
\item Affects system design and communication methods

\subsection{I/O Bus Connections}

\subsubsection{Simplified System Architecture}

\paragraph{Components}

\begin{itemize}
\item \textbf{Processor (CPU)}
\item \textbf{Cache}
\item \textbf{Memory I/O Interconnect (Bus)}
\item \textbf{Main Memory}
\item \textbf{Multiple I/O Controllers}
\item \textbf{Various I/O Devices}

\paragraph{Bus Structure}

\begin{itemize}
\item Processor and cache connected to bus
\item Main memory connected to bus
\item I/O controllers connected to bus
\item Each controller manages specific devices

\paragraph{Connections}

\begin{itemize}
\item Processor receives interrupts from bus/devices
\item \textbf{I/O Controller 1}: Connected to disk
\item \textbf{I/O Controller 2}: Connected to graphic output
\item \textbf{I/O Controller 3}: Connected to network channel

Multiple controllers allow parallel device operation while sharing common interconnect.

\subsection{Dependability}

Critical for I/O systems, especially storage devices.

\subsubsection{Why Dependability Matters}

\begin{itemize}
\item Storage devices hold data that must be reliable
\item Users depend on devices being available
\item Data loss is unacceptable
\item Systems must continue functioning despite component failures

\subsubsection{Dependability is Particularly Important For}

\begin{itemize}
\item Storage devices (data integrity)
\item Critical systems (servers, embedded systems)
\item Systems with high availability requirements

\subsection{Service States}

\subsubsection{Two Primary States}

\paragraph{1. Service Accomplishment State}

\begin{itemize}
\item Device is working correctly
\item Providing expected service
\item Normal operational state

\paragraph{2. Service Interruption State}

\begin{itemize}
\item Device has failed
\item Not providing service
\item Requires repair/restoration

\subsubsection{State Transitions}

\begin{itemize}
\item \textbf{From Service Accomplishment to Service Interruption}: Due to failure
\item \textbf{From Service Interruption to Service Accomplishment}: After restoration/repair

\subsection{Fault Terminology}

\subsubsection{Fault Definition}

\textbf{Characteristics}:

\begin{itemize}
\item Failure of a component
\item May or may not affect the system
\item May or may not lead to system failure
\item System can continue running with faulty component
\item May produce correct or wrong output

\subsubsection{Distinction}

\begin{itemize}
\item \textbf{Component failure $\neq$ System failure}
\item Fault tolerance allows operation despite faults

\subsection{Dependability Measures}

\subsubsection{Key Metrics}

\paragraph{1. MTTF (Mean Time To Failure)}

\textbf{Definition}:

\begin{itemize}
\item Reliability measure
\item Average time device operates before failing
\item Measures how long system stays in Service Accomplishment state
\item Higher MTTF = more reliable

\paragraph{2. MTTR (Mean Time To Repair)}

\textbf{Definition}:

\begin{itemize}
\item Service interruption measure
\item Average time to restore service after failure
\item How long device stays in Service Interruption state
\item Lower MTTR = faster recovery

\paragraph{3. MTBF (Mean Time Between Failures)}

\textbf{Formula}:

MTBF = MTTF + MTTR

\textbf{Definition}:

\begin{itemize}
\item Complete cycle: operation + repair
\item Time from one failure to next failure
\item Includes both operational and repair time

\paragraph{4. Availability}

\textbf{Formula}:

Availability = MTTF / (MTTF + MTTR)

\textbf{Definition}:

\begin{itemize}
\item Proportion of time machine is available
\item Ratio of operational time to total time
\item Expressed as percentage or decimal

\subsection{Improving Availability}

\subsubsection{Two Approaches}

\begin{itemize}
\item MTTF
\item MTTR

\subsection{Increase MTTF (Mean Time To Failure)}

\paragraph{a) Fault Avoidance}

\textbf{Methods}:

\begin{itemize}
\item Prevent faults before they occur
\item Better design and manufacturing
\item Quality components
\item Proper operating conditions

\paragraph{b) Fault Tolerance}

\textbf{Methods}:

\begin{itemize}
\item Design system to withstand faults
\item Redundancy (duplicate components)
\item Error correction mechanisms
\item Graceful degradation

\paragraph{c) Fault Forecasting}

\textbf{Methods}:

\begin{itemize}
\item Predict when faults will occur
\item Preventive maintenance
\item Monitor component health
\item Replace before failure

\subsection{Reduce MTTR (Mean Time To Repair)}

\subsubsection{Methods}

\begin{itemize}
\item Improve tools and processes for diagnosis
\item Better diagnostic capabilities
\item Easier repair procedures
\item Quick replacement mechanisms
\item Automated recovery systems
\item Skilled maintenance personnel

\subsubsection{Example Problems}

\begin{itemize}
\item Book provides examples with specific MTTF and MTTR values
\item Calculate availability
\item Analyze improvement strategies
\item Students should practice these calculations

\subsection{Magnetic Disk Storage}

Traditional secondary storage technology using magnetic recording.

\subsubsection{Physical Structure}

\paragraph{Disk Shape}

\begin{itemize}
\item Circular/round shape
\item Platter rotates on spindle

\paragraph{Tracks}

\begin{itemize}
\item Concentric circles on disk surface
\item From periphery (outer edge) to center
\item Multiple tracks like ribbons arranged concentrically
\item Similar to running tracks in sports (Olympics)

\paragraph{Sectors}

\begin{itemize}
\item Tracks divided by radial lines (from center to periphery)
\item Cross-sectional cuts across tracks
\item Portion between two separation lines = one sector
\item Smallest addressable unit on disk

\subsubsection{Sector Contents}

\begin{itemize}
\item \textbf{Sector ID} (identification)
\item \textbf{Data} (512 bytes to 4096 bytes typical)
\item \textbf{Error Correcting Code (ECC)}
\item Hides defects
\item Corrects recording errors
\item \textbf{Gaps} between sectors (unused spaces)

\subsection{Disk Access Process}

\subsubsection{Access Components and Timing}

\paragraph{1. Queuing Delay}

\begin{itemize}
\item If other accesses are pending
\item Wait for previous operations to complete
\item Managed by disk controller

\paragraph{2. Seek Time}

\begin{itemize}
\item Moving head to correct track
\item Head positioned on right sector
\item Physical movement of read/write head
\item Head placed diagonally on disc
\item Time to "seek" the target sector
\item Typically several milliseconds

\paragraph{3. Rotational Latency}

\begin{itemize}
\item Rotating disk to position correct sector under head
\item Disk spins to align sector with head
\item Choose closest direction (shortest rotation)
\item Sectors arranged diagonally on disk
\item Multiple sectors per track
\item Can rotate either direction (clockwise or counterclockwise)

\paragraph{4. Transfer Time}

\begin{itemize}
\item Actual data read/write
\item Depends on sector size and transfer rate
\item Usually small compared to seek and rotation

\paragraph{5. Controller Overhead}

\begin{itemize}
\item Processing by disk controller
\item Command interpretation
\item Error checking
\item Generally small (fraction of millisecond)

\subsubsection{Access Coordination}

\begin{itemize}
\item Processor initiates access
\item Memory Management Unit (MMU) handles translation
\item Involves both hardware and operating system
\item Reading page from disk to memory: millions of cycles
\item Much slower than memory access

\subsection{Disk Access Example Calculation}

\subsubsection{Given Parameters}

\begin{itemize}
\item \textbf{Sector size}: 512 bytes
\item \textbf{Rotational speed}: 15,000 RPM (rotations per minute)
\item \textbf{Seek time}: 4 milliseconds
\item \textbf{Transfer rate}: 100 MB/s
\item \textbf{Controller overhead}: 0.2 milliseconds
\item Assume idle disk (no queuing)

\subsubsection{Average Read Time Calculation}

\paragraph{1. Seek Time}

\begin{itemize}
\item 4 ms (given)

\paragraph{2. Rotational Latency}

\begin{itemize}
\item Average = Half rotation time
\item Full rotation = 60 seconds / 15,000 RPM = 4 ms
\item Average = 4 ms / 2 = \textbf{2 ms}
\item Why half? Can choose closest direction

\paragraph{3. Transfer Time}

\begin{itemize}
\item Size / Rate = 512 bytes / 100 MB/s
\item = \textbf{0.005 ms}

\paragraph{4. Controller Delay}

\begin{itemize}
\item 0.2 ms (given)

\subsubsection{Total Average Read Time}

Total = 4 + 2 + 0.005 + 0.2 = 6.2 milliseconds

\subsubsection{Real Case Variation}

\begin{itemize}
\item Actual average seek time might be 1 ms (not 4 ms)
\item Depends on:
\item Which sector being accessed
\item Current head position
\item Distance head must travel
\item With 1 ms seek: Total = \textbf{3.2 ms}
\item Significant variation based on access patterns

\subsubsection{Additional Examples}

\begin{itemize}
\item Book provides more practice problems
\item Students should try different scenarios
\item Understand impact of each component on total time

\subsection{Flash Storage}

Modern non-volatile semiconductor storage technology.

\subsubsection{Characteristics}

\paragraph{Advantages}

\begin{itemize}
\item Non-volatile (retains data without power)
\item 1000x faster than magnetic disk
\item Smaller physical size
\item Lower power consumption
\item More robust (no moving parts)
\item Can be carried around easily
\item Shock resistant

\paragraph{Disadvantages}

\begin{itemize}
\item More expensive than magnetic disk
\item Limited write cycles (wears out over time)
\item Technology cost higher

\subsection{Types of Flash Storage}

\subsubsection{NOR Flash}

\paragraph{Structure}

\begin{itemize}
\item Bit cell like NOR gate
\item Random read/write access
\item Can access individual bytes

\paragraph{Characteristics}

\begin{itemize}
\item Byte-level access
\item Faster read access
\item More expensive

\paragraph{Applications}

\begin{itemize}
\item Instruction memory in embedded systems
\item Code storage
\item Execute-in-place applications

\subsubsection{NAND Flash}

\paragraph{Structure}

\begin{itemize}
\item Bit cell like NAND gate
\item Block-at-a-time access
\item Cannot access individual bytes directly

\paragraph{Characteristics}

\begin{itemize}
\item Denser (more storage per area)
\item Block-level access
\item Reading and writing done in blocks
\item Cheaper per GB

\paragraph{Applications}

\begin{itemize}
\item USB keys/drives
\item Media storage (photos, videos)
\item Solid-state drives (SSDs)
\item Memory cards

\textbf{Note}: Values in lecture slides may be outdated as flash storage technology rapidly evolves.

\subsection{Memory-Mapped I/O}

Method of accessing I/O devices using memory addresses.

\subsubsection{Concept}

\begin{itemize}
\item Reserve some address space for I/O devices
\item I/O device registers appear as memory locations
\item Same address space as memory
\item Address decoder distinguishes between memory and I/O

\subsubsection{Example with 8 Address Lines}

\begin{itemize}
\item \textbf{Total addressable locations}: 256 (2^8)
\item \textbf{Reserve 128 locations for memory}
\item \textbf{Reserve 128 locations for I/O devices}
\item Same load/store instructions access both

\subsubsection{Access Mechanism}

\begin{itemize}
\item Use load/store instructions for both memory and I/O
\item Operating system controls access
\item Uses address translation mechanism
\item Can make I/O addresses accessible only to kernel
\item Protection mechanism prevents user programs from direct access

\subsubsection{Advantages}

\begin{itemize}
\item Unified programming model
\item Same instructions for memory and I/O
\item Simpler instruction set

\subsubsection{Disadvantages}

\begin{itemize}
\item Reduces available memory address space
\item Must reserve addresses for I/O

\subsection{I/O Instructions}

Alternative to memory-mapped I/O: separate I/O instructions.

\subsubsection{Characteristics}

\begin{itemize}
\item Separate instructions specifically for I/O operations
\item Distinct from load/store (memory) instructions
\item Can duplicate addresses:
\item Same address can refer to memory location
\item Same address can refer to I/O device
\item Instruction type determines which is accessed

\subsubsection{Access Control}

\begin{itemize}
\item I/O instructions can only execute in kernel mode
\item User programs cannot directly access I/O
\item Protection mechanism
\item Operating system mediates I/O access

\subsubsection{Example Architecture}

\begin{itemize}
\item \textbf{x86 (Intel/AMD processors)}
\item Has special IN and OUT instructions for I/O
\item Separate I/O address space

\subsubsection{Advantages}

\begin{itemize}
\item Full memory address space available
\item No address space conflict
\item Clear distinction between memory and I/O

\subsubsection{Disadvantages}

\begin{itemize}
\item More complex instruction set
\item Additional instructions needed

\subsection{Polling}

Method for processor to communicate with I/O devices.

\subsubsection{How Polling Works}

\paragraph{1. Periodically Check I/O Status Register}

\begin{itemize}
\item Processor repeatedly reads device status
\item Check if device is ready
\item Continuous monitoring in loop

\paragraph{2. If Device Ready}

\begin{itemize}
\item Perform requested operation
\item Read data or write data
\item Continue with next task

\paragraph{3. If Error Detected}

\begin{itemize}
\item Take appropriate action
\item Error handling
\item Retry or report error

\subsubsection{Characteristics}

\paragraph{When Used}

\begin{itemize}
\item Small or low-performance systems
\item Real-time embedded systems
\item Simple applications

\paragraph{Advantages}

\textbf{Predictable Timing}:

\begin{itemize}
\item Know exactly when device checked
\item Deterministic behavior
\item Important for real-time systems

\textbf{Low Hardware Cost}:

\begin{itemize}
\item Software handles communication
\item No additional hardware needed
\item Simple implementation

\paragraph{Disadvantages}

\textbf{Wastes CPU Time}:

\begin{itemize}
\item CPU continuously loops checking device
\item Can't do other work while polling
\item Inefficient for high-performance systems

\textbf{Not Suitable for Complex Systems}:

\begin{itemize}
\item Multiple devices difficult to manage
\item CPU time wasted on idle devices

\subsubsection{Programming Model}

\begin{itemize}
\item Can write program to:
\item Read status bit from device
\item Check if device free
\item Make decisions based on status
\item Simple control flow

\subsection{Interrupts}

Alternative to polling: device-initiated communication.

\subsubsection{How Interrupts Work}

\paragraph{1. Device Initialization}

\begin{itemize}
\item Device sends signal/request to processor
\item Request for service
\item Happens when device ready or error occurs

\paragraph{2. Controller Interrupts CPU}

\begin{itemize}
\item Device controller signals processor
\item Processor stops current work
\item Handles interrupt

\paragraph{3. Handler Execution}

\begin{itemize}
\item Special interrupt handler routine runs
\item Services device request
\item Returns to original program

\subsubsection{Characteristics}

\paragraph{Asynchronous}

\begin{itemize}
\item Not synchronized to instruction execution
\item Unlike exceptions (which are synchronous)
\item Can occur between any two instructions
\item Handler invoked between instructions

\paragraph{Fast Identification}

\begin{itemize}
\item Interrupt often identifies device
\item Know which device needs service
\item Can be handled quickly

\paragraph{Priority System}

\begin{itemize}
\item Not all devices have same urgency
\item Devices categorized by priority levels
\item Devices needing urgent attention get higher priority
\item High-priority interrupts can preempt low-priority handlers

\subsubsection{Advantages}

\textbf{Efficient CPU Use}:

\begin{itemize}
\item No wasted time polling
\item CPU does other work until interrupt

\textbf{Good for Multiple Devices}:

\begin{itemize}
\item Each device interrupts when ready
\item No continuous checking needed

\textbf{Responsive}:

\begin{itemize}
\item Quick response to device events

\subsubsection{Disadvantages}

\textbf{More Complex Hardware}:

\begin{itemize}
\item Interrupt controller needed
\item Priority management

\textbf{Context Switching Overhead}:

\begin{itemize}
\item Save/restore processor state
\item Handler invocation takes time

\subsubsection{Execution Model}

\begin{itemize}
\item Main program running
\item Instruction completes
\item Interrupt checked
\item If interrupt pending:
\item Current state saved
\item Interrupt handler runs
\item State restored
\item Resume main program at next instruction

\subsection{I/O Data Transfer Methods}

Three approaches for transferring data between memory and I/O:

\subsection{Polling-Driven I/O}

\subsubsection{Process}

\begin{itemize}
\item CPU polls device repeatedly
\item When ready, CPU transfers data
\item CPU moves data between memory and I/O registers

\subsubsection{Issues}

\begin{itemize}
\item Time consuming
\item CPU fully involved in transfer
\item Inefficient for high-speed devices
\item Wastes CPU cycles

\subsection{Interrupt-Driven I/O}

\subsubsection{Process}

\begin{itemize}
\item Device interrupts when ready
\item CPU services interrupt
\item CPU transfers data between memory and I/O registers

\subsubsection{Issues}

\begin{itemize}
\item Still CPU-intensive for data transfer
\item CPU must move every byte
\item Better than polling but still inefficient for bulk transfers

\subsection{Direct Memory Access (DMA)}

\subsubsection{Process}

\textbf{Setup}:

\begin{itemize}
\item DMA controller handles transfer
\item Removes CPU from data movement
\item Processor hands off transfer job to DMA controller
\item DMA controller transfers data autonomously

\subsubsection{DMA Operation}

\textbf{CPU Provides}:

\begin{itemize}
\item Starting address in memory
\item Transfer size
\item Direction (memory$\rightarrow$device or device$\rightarrow$memory)

\textbf{DMA Controller}:

\begin{itemize}
\item Transfers data independently
\item Operates in parallel with CPU
\item No CPU intervention during transfer

\textbf{Controller Interrupts CPU On}:

\begin{itemize}
\item Completion of transfer
\item Error occurrence

\subsubsection{Advantages}

\begin{itemize}
\item CPU free to do other work
\item Efficient bulk data transfers
\item Essential for high-speed devices
\item Reduces CPU overhead significantly

\subsubsection{When Used}

\begin{itemize}
\item High-speed devices (disks, network)
\item Large data transfers
\item When CPU time is valuable

\subsubsection{Comparison}

\begin{itemize}
\item \textbf{Polling}: Simple, predictable, inefficient
\item \textbf{Interrupts}: Responsive, better than polling, CPU still involved in transfer
\item \textbf{DMA}: Most efficient, essential for high-performance I/O

\subsection{RAID (Redundant Array of Independent Disks)}

Technology to improve storage performance and dependability.

\subsubsection{Purpose}

\begin{itemize}
\item Improve performance through parallelism
\item Improve dependability through redundancy
\item Use multiple disks together as single logical unit

\subsubsection{Benefits}

\paragraph{Performance Improvement}

\begin{itemize}
\item Parallel access to multiple disks
\item Higher throughput
\item Faster data access

\paragraph{Dependability Improvement}

\begin{itemize}
\item Redundancy protects against disk failure
\item Data not lost if one disk fails
\item Improved reliability

\subsection{Key Takeaways}

\begin{enumerate}
\item I/O systems connect computers to external devices and storage
\item Dependability is critical for storage systems
\item MTTF, MTTR, and availability are key metrics
\item Magnetic disks use mechanical components with millisecond access times
\item Flash storage is faster but more expensive than magnetic storage
\item Memory-mapped I/O and separate I/O instructions are two access methods
\item Polling is simple but inefficient
\item Interrupts improve CPU efficiency
\item DMA is essential for high-speed bulk data transfers
\end{enumerate}

10. RAID improves both performance and reliability

\subsection{Summary}

This concludes the processor and memory sections of the lecture, covering the complete spectrum from CPU design through memory hierarchy to I/O systems. We have explored how computers are designed from the ground up, from basic arithmetic operations through pipelined execution, memory hierarchies, multiprocessor systems, and finally to storage and I/O mechanisms that enable computers to interact with the external world.
